title: "编写可维护的javascript阅读笔记"
date: 2015-11-15 22:17:11
categories: 书籍阅读
tags: [js质量]
---


##编写可维护的javascript阅读总结

----------
#####by 南洋 2015 11 14
----------
### 第一部分 编程风格
----------
**（一）、基本的格式化**
**1.1缩进层级**
第一种方式是使用制表符进行缩进，就是tab键好处是可以统一配置编辑器的配置改变制表符的长度，缺点是tab的表现在不同系统的变现可能不同，这样也会出现代码风格的不统一。
第二种方式是使用空格键，几个空格键代表一个缩进。
**我个人而言喜欢使用空格缩进并且两个空格代表一个缩进。**

**1.2语句结尾**
除了函数定义以外的代码结尾，都要加上分号，以免分析器错误的自动加上一些不必要的分号。

**1.3行的长度**
关于行的长度，sublime里有78的选项，个人一般会选择这个选项。如果长度太长，在浏览器里会超出视线，而且在github上也会出现横向滚动条，这都是阅读代码时不想看到的。

**1.4空行的使用**
这点自己做的不是很好，在书里出现的规则是：
 - 在流控制语句前加空行，比如if for
 - 在方法内的局部变量与逻辑代码之间
 - 每个方法之间
 - 注释上下行

**1.5命名**
> 都采用驼峰式进行命名

变量：前缀用名词，且名词能体现出这个变量的数据类型。
eg： countBox lengthBox msgUser

方法：前缀用动词
can has is set get

常量：
MAX_LENGTH
```
if (count > MAX_LENGTH) {
	//TO DO
}
```


**1.7基本量**
1.7.1字符串
字符串可以用双引号也可以用单引号，值得注意的是整个文件需要保持对这种字符串风格的统一。
个人比较喜欢用单引号。

1.7.2数字
不要省略0.4之前的0

**（二）、注释**
**2.1单行注释**
单独一行，用来注释下一行代码，注释的上一行要为空行。注释的缩进要和下一行的代码缩进相同。
或者注释在一行代码的尾部，要求注释的字数要少。注释与前的代码之间要有至少一个缩进。

**2.2多行注释**
多行注释出现在需要注释的一段代码之前，注释与代码之间没有空行，注释的上一行为空行。多行注释一般用来注释不好理解的代码段落。


**（三）、语句与表达式**
**3.1花括号的对其方式**
花括号跟随语句之后，不另起一段。
```
//使用
if (true) {

  //todo
}

//不使用
if (true) 
{

 //todo
}
```

**3.2块语句的空格问题**
个人喜欢并自我强制使用左圆括号左、右圆括号右加空格
```
if (true) {

}
```

**（四）、变量、函数及运算符**
**4.1变量声明**
因为会有变量提升的现象，浏览器在执行一个函数时首先定义了这个函数内的变量名，并且赋值undefied。所以我们在函数内定义的变量都可以提前写在函数内的开头，并且使用单var模式。

**4.2函数声明**
函数声明也有提升的现象，所以执行写在定义之前也是行的，但规范来讲函数的定义最好是在变量定义完之后跟上。而且函数定义不要在条件语句中出现。

**4.3相等**
当执行==操作时，js会将一方的值强制转换成与另一方数据类型相等，然后进行比较。
eg："1" == 1
1 == true
0 == false
true会被转换成1
所以想进行比较的时候用`===`，不会进行数据类型的转换。


### 第二部分 编程实践
----------
**（五）、UI层的松耦合**
这章主要讲的是UI层三要素`html css jacascript`之间如何尽量消除耦合。
 - html html文档中不要出现style内嵌css属性，也不要出现内嵌的js，比如onclick。
 - css css中不允许出现表达式内嵌javascript
 - javascript中尽量不要出现直接操作css的语句，改而用`className`代替，另外javascript尽量不要拼接html操作dom，改而使用客户端模板引擎或者后端直接吐一整段html出来。

总结：个人平时使用中，其他几点基本都能做到，但在javascript中还是经常去拼接一些html，在以后的工作中，尽量用前端模板引擎代替。


**（六）、避免使用全局变量**
> 在整个工程下使用全局变量，很容易覆盖掉别人写的一些变量，或者是自己定义的变量被别人错误的覆盖。

一些解决办法：

1、命名空间
可以在全局window变量下自定义一个全局变量，而且这个全局变量具有很大的辨识度，不会覆盖掉浏览器的api。
```
var nanyangTask = {};
```
然后所有的方法属性全部定义在这个全局变量之下。
```
nanyangTask.book = function () {

	//todo
}
```

2、模块加载
模块是一种通用的代码片段，存放在一个表示执行一个任务或发布一个接口的单函数中，这些代码片段不会影响到全局变量。
公司中使用的seajs遵循cmd规范，在define()全局函数中写逻辑代码就可。

3、自执行函数，在自执行函数中定义的方法只要都带上var就不会污染全局变量，在不要给抛出接口的一些代码片段比较适合使用这种方式，比如现在在公司的活动营销页面的制作。

**（七）、事件处理**
**7.2隔离应用逻辑**
先来看一段平时写的很多的时间绑定逻辑
```
function handleClick(ev) {
	var a = document.getElementById('X');
	a.style.left = ev.clientX + 'px';
}
$(document).on('click', handleClick);
```

handleClick方法中的逻代码片段是一段应用逻辑，跟业务逻辑紧密相关，但是设想一下，现在的逻辑是在页面中点击一下，元素移动到鼠标的位置，但是还有一处业务逻辑是长按一下，元素移动到鼠标的位置。如此就要复制一段代码。所以我们要做的就是将应用的逻辑抽离出来。
```
function handleClick(ev) {
	moveBox(ev)
}
function moveBox(ev) {
	var a = document.getElementById('X');
	a.style.left = ev.clientX + 'px';
} 
$(document).on('click', function(ev) {
	handleClick(ev)
});
```
如此一来，moveBox方法就可以在多个地方调用。


**7.3不要分发事件对象**
上面的7.2还是有一些不好的地方，event事件对象被分发了很多次，首先传到事件处理程序handleClick，再传到应用逻辑函数moveBox，实际上应用逻辑是有很明确的目的的，这代表了这个方法会用到事件对象的哪些属性。所以修改下代码。
```
function handleClick(ev) {
	moveBox(ev.clientX);
}
function moveBox(x) {
	var a = document.getElementById('X');
	a.style.left = x + 'px';
} 
$(document).on('click', function(ev) {
	handleClick(ev)
});
```
这样做的好处是应用逻辑可以明确知道是干什么的，并且这样方便了测试，测试时不需要模拟事件，直接调用`moveBox(10)`就好了。
另外对于事件处理程序的一些方法，比如阻止默认事件，阻止冒泡都写在事件处理程序`handleClick`中，进一步分离事件处理程序和应用逻辑。

**（八）、避免空比较**
**8.1检测原始值**
javascript有5种原始值 
  - number
  - string
  - boolean
  - null
  - undefined

检测number、string、boolean、endefined四种数据类型使用`typeof`非常实用也安全，返回的就是这四种类型。
null一般不用于检测，除非某个返回值就是null，例如document.getElementById('#rff');如果没有这个 节点，返回的就是null。

**8.2检测引用值**
引用类型包括数组、对象、函数等除了原始值之外的数据类型。
typeof检测这些类型返回的都是object。
所以检测引用类型的方法可以用instanceof
[] isstanceof Array === true

最新方法：
Object.prototype.toString().call(value) === "[object Array]"  

**8.3判断对象的属性是否存在**
```
var object = {
	arrd: 'd'
}
```
 - in if ( 'arrd' in object ) {}
 - hasOwnProperty  if (object hasOwnProperty 'arrd') {}
两者的区在在于，in检测arrd这个属性是否是这个object实例的，但如果是其原型上的属性，也返回true，但hasOwnProperty只检测是否是实例的属性。

**（九）、将配置数据从代码中分离出来**
**9.1什么是配置数据**
简单来讲就是在js逻辑里定死的数据，只能通过人为的去改的数据
```
if (size > 90) {}
```
在上面一段代码中，MAX_SIZE就是一个配置数据，在代码中固定。

**9.2抽离配置数据**
将js逻辑代码里的配置数据都抽离出来存放在config对象中去。
```
var config = {
	MSG_INVALID_VALUE: 'Invalid value',
	URL_INVALID: 'XXX',
	CSS_APP: 'select'
}
```
规范下，配置数据即定数据采用全大写的方式，首单词标明了这个数据的类型。

**（十一）、不是你的对象不要动**
简单来讲，就是处理自己的逻辑代码，绝不尝试修改，覆盖，删除window的属性方法，绝不Object原型上的方法属性，或者是自己同事的代码。


**（十二）、浏览器嗅探**
**12.1user-agent**
处理兼容性上这是最后的办法，会由很大的不准确性，真的要检测useragent也要首先检测旧版本，并进行一些hack，else的情况执行正常的逻辑代码。

**12.2特性检测**
特性检测并不是去检测是什么浏览器，因为对于某些特性，会有多个浏览器支持。
正确的特性检测的一些重要组成部分
 - 探测标准的方法
 - 探测不同浏览器的特定方法。

**值得注意的是千万不要根据特性去判断是什么浏览器**
比如
> var isIE = !!documenr.all 现在docuemnt.all是ie的特型，但是不应该通过这个特型去决定是否是一个浏览器，因为，假如哪天ie删除了这个属性，而isIE这个变量又大量用于文件中，会引起很多问题。
